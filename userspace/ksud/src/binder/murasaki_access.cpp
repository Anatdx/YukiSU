// Murasaki access control helpers (implementation)

#include "murasaki_access.hpp"

#include "../core/ksucalls.hpp"
#include "../log.hpp"

#include <cerrno>
#include <cstdio>
#include <fstream>
#include <mutex>
#include <set>
#include <string>

namespace ksud::access {

namespace {

// Keep this simple + stable. One UID per line.
static constexpr const char* kMurasakiAllowlistPath = "/data/adb/ksu/.murasaki_allowlist";

static std::mutex g_acl_mutex;
static bool g_acl_loaded = false;
static std::set<uid_t> g_acl;

static void load_acl_locked() {
    if (g_acl_loaded) {
        return;
    }
    g_acl_loaded = true;
    g_acl.clear();

    std::ifstream ifs(kMurasakiAllowlistPath);
    if (!ifs) {
        return;
    }

    std::string line;
    while (std::getline(ifs, line)) {
        if (line.empty() || line[0] == '#') {
            continue;
        }
        char* end = nullptr;
        errno = 0;
        long v = std::strtol(line.c_str(), &end, 10);
        if (errno != 0 || end == line.c_str()) {
            continue;
        }
        if (v <= 0) {
            // never store uid 0; manager/root is handled separately
            continue;
        }
        g_acl.insert(static_cast<uid_t>(v));
    }
}

static bool save_acl_locked() {
    // Write-then-rename for best-effort atomic update
    std::string tmp = std::string(kMurasakiAllowlistPath) + ".tmp";
    {
        std::ofstream ofs(tmp, std::ios::trunc);
        if (!ofs) {
            LOGE("Failed to write %s", tmp.c_str());
            return false;
        }
        ofs << "# Auto-generated by ksud (Murasaki/Shizuku access list)\n";
        for (uid_t uid : g_acl) {
            ofs << static_cast<uint32_t>(uid) << "\n";
        }
        ofs.flush();
    }

    if (std::rename(tmp.c_str(), kMurasakiAllowlistPath) != 0) {
        LOGE("Failed to rename allowlist: %s -> %s (errno=%d)",
             tmp.c_str(), kMurasakiAllowlistPath, errno);
        // best-effort cleanup
        std::remove(tmp.c_str());
        return false;
    }
    return true;
}

}  // namespace

std::optional<uid_t> get_manager_uid() {
    auto uid = ::ksud::get_manager_uid();
    if (!uid.has_value()) {
        return std::nullopt;
    }
    // kernel uses KSU_INVALID_UID = -1, but transported as u32
    if (static_cast<uint32_t>(*uid) == 0xFFFFFFFFu) {
        return std::nullopt;
    }
    return *uid;
}

bool is_manager_uid(uid_t uid) {
    auto mgr = get_manager_uid();
    return mgr.has_value() && uid == *mgr;
}

bool is_murasaki_allowed(uid_t uid) {
    if (uid == 0) {
        return true;
    }
    if (is_manager_uid(uid)) {
        return true;
    }
    std::lock_guard<std::mutex> lock(g_acl_mutex);
    load_acl_locked();
    return g_acl.find(uid) != g_acl.end();
}

bool grant_murasaki(uid_t uid) {
    if (uid == 0) {
        return true;
    }
    std::lock_guard<std::mutex> lock(g_acl_mutex);
    load_acl_locked();
    g_acl.insert(uid);
    return save_acl_locked();
}

bool revoke_murasaki(uid_t uid) {
    if (uid == 0) {
        return false;
    }
    std::lock_guard<std::mutex> lock(g_acl_mutex);
    load_acl_locked();
    g_acl.erase(uid);
    return save_acl_locked();
}

std::vector<int32_t> list_murasaki_uids() {
    std::lock_guard<std::mutex> lock(g_acl_mutex);
    load_acl_locked();
    std::vector<int32_t> out;
    out.reserve(g_acl.size());
    for (uid_t uid : g_acl) {
        out.push_back(static_cast<int32_t>(uid));
    }
    return out;
}

}  // namespace ksud::access

